---
title: 'High Pace Tech Careers'
description: 'Web dev is like NASCAR'
pubDate: 'Jan 20 2025'
heroImage: '/images/blog/blog-post-4.jpg'
pinned: false
---

My neighbor and I recently spent a morning clearing out the dry brush behind our fences. Fun fact, I now have proof that I can not only sharpen my cutlery with a whetstone, but I can also do the same with a machete and file. But that's not the thing we're talking about right now. The rabbithole we're going down is related to our conversation after a full body exercise (who needs a gym membership when you can move logs and branches).

If you couldn't tell by the title, we talked about our careers. I knew he is retired and a veteran, but I didn't know much else. For those who haven't read my [piece from last August](https://rohbot.dev/blog/001-failed-premed/), I have a degree in Computer Science, and have been working as a software engineer across a variety of industries for nearly twice as long as I'd been in school for it. Now my neighbor on the flipside, he joined the US Armed Forces some time in the 60s, I forget when exactly. During basic training he was one of the few people who mentioned he knew some programming, and he found himself up working in DC and around the world.

In some ways, what he described sounded straight out of a history textbook. They had these centralized mainframe computers on which they'd run punchcards. First they would have to write out their program by hand on a coding sheet. Then they'd take to a special typewriter that would punch specific holes in a card based on what was pressed, typically it would be one command per. They'd then take these over to another machine to verify that the program ran correctly. After that they would use a different machine to mark the order the punchcards should run in. And then finally they'd go to the central computer room to run it. What was the output? More printed sheets of course.

But in other ways it sounded familiar. Sketch out an idea on a whiteboard or paper. Write some code. If you're lucky, have a compiler catch problems with the code. Regardless of static or dynamic, run tests to make sure you didn't break anything. Run it locally, make sure it still works. Before the cloud era, we'd ftp that over to a server in the closet, and run it again. Nowadays, we'd push to the hosted Git provider. Make a PR. Kick off CI/CD. Check it deployed correctly. Stopping here before we go into the various options for deployment strategies, but y'all see what I'm seeing right? It's not the same, but definitely rhymes. We still have a lot of steps between the human writing a high level language, going through various steps to make sure the code works before sending it off to some final machine to run.

We've even had loops in that final machine. At first we had the big central computer room. Then personal computing improving in conjunction with the spread of the internet let the server move to  your basement. To now our current reality where a handful of big companies operate data centers that manage not just that last machine, but the global distribution of it, (along with every possible wrapper service, but we're not talking about that today).

So what's the point of all of this? Well it's that I'm beginning to question the notion that "tech" is a high-paced industry and that everything is constantly changing. Sure there's always a new language, a new library, new framework, new tool, and so on. But at the end of the day, not much is different. We are still composing complicated spells to impose our will on the magical rock we ran lightning through to do math. Or in other words, leveraging a high level language to instruct the CPU to do something. Sure the machines look a lot sleeker and a lot of it is virtualized, but the fundamentals aren't that different now vs his time nearly 50 years ago.
